//NoT TESTED//

#include "WiFi.h"
#include "HTTPClient.h"
#include "ArduinoJson.h"
#include <GxEPD2_BW.h>
#include <Fonts/FreeMonoBold9pt7b.h>
#include <U8g2_for_Adafruit_GFX.h>
#include "time.h"
#include <tinyxml2.h>

using namespace tinyxml2;
// Constants
#define uS_TO_S_FACTOR 1000000ULL // Conversion factor for microseconds to seconds
#define DEEP_SLEEP_DURATION 600   // Sleep duration in seconds (10 minutes)
#define RSS_FETCH_INTERVAL 28      // Fetch RSS every 6 wake-ups (4.6 hour)
#define CALENDAR_FETCH_INTERVAL 18 // Fetch calendar every 18 wake-ups (3 hours)
#define WAKEUP_TIME 7  // 7:00 AM
#define SLEEP_TIME 1  // 1:00 AM

// Persistent variables using RTC memory
RTC_DATA_ATTR int currentTitleIndex = 0; // Tracks the index of the news title
RTC_DATA_ATTR int wakeUpCount = 0;       // Tracks wake-up cycles for RSS fetch
RTC_DATA_ATTR int newsCount = 0;  // Store the number of news titles in RTC memory
RTC_DATA_ATTR char newsTitles[28][100] = {{0}}; // Store news titles directly in RTC memory
RTC_DATA_ATTR char calendarPayload[180] = {0};


// WiFi credentials
#define WIFI_SSID "MINDTHESUGAR.ORG"
#define WIFI_PASSWORD "Francja#32193219"

// OpenWeatherMap API
#define URL "http://api.openweathermap.org/data/2.5/weather?q=Oxford,UK&APPID=7292bc321dd0ad8d36adf489d5c6e0ff&mode=json&units=metric&cnt=40"

const char* CALENDAR_URL = "https://script.google.com/macros/s/AKfycbwyA-OFerArJLsOC2azIg3rOw80u4KxmP6lkDckQNlStNJBSKR_EnW8lcqi0SxrxKTO0A/exec";

const char* RSS_URL = "https://feeds.bbci.co.uk/news/world/rss.xml";

// ePaper display setup
//1 BUSY  GPIO4
//2 RES GPIO2
//3 D/C GPIO3
//4 CS  GPIO5
//5 SCL GPIO12
//6 SDA GPIO11
//7 GND GND
//8 VCC 3V3

GxEPD2_BW<GxEPD2_420_GDEY042T81, GxEPD2_420_GDEY042T81::HEIGHT> display(GxEPD2_420_GDEY042T81(/*CS=*/ 5, /*DC=*/ 3, /*RES=*/ 2, /*BUSY=*/ 4));

StaticJsonDocument<8192> doc;
HTTPClient http;

void setTimezone(String timezone) {
  Serial.printf("  Setting Timezone to %s\n", timezone.c_str());
  setenv("TZ", timezone.c_str(), 1);
  tzset();
}

void initTime(String timezone) {
  struct tm timeinfo;
  Serial.println("Setting up time");
  configTime(0, 0, "pool.ntp.org");
  if (!getLocalTime(&timeinfo)) {
    Serial.println("  Failed to obtain time");
    return;
  }
  Serial.println("  Got the time from NTP");
  setTimezone(timezone);
}

String getLocalTimeString() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    Serial.println("Failed to obtain time");
    return "Time N/A";
  }
  char timeStringBuff[50];
  strftime(timeStringBuff, sizeof(timeStringBuff), "%a %d %b %H:%M", &timeinfo);
  return String(timeStringBuff);
}

void wifi_init() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWiFi connected.");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());
  initTime("GMT0BST,M3.5.0/1,M10.5.0");
}

void downloadWeather() {
  http.begin(URL);
  int httpResponseCode = http.GET();
  if (httpResponseCode > 0) {
    String json = http.getString();
   // Serial.println("Raw JSON data:");
   // Serial.println(json);
    int startIndex = json.indexOf('{');
    if (startIndex != -1) {
      json = json.substring(startIndex);
    }
    DeserializationError error = deserializeJson(doc, json);
    if (error) {
      Serial.printf("Deserialization failed: %s\n", error.c_str());
    } else {
      Serial.println("JSON parsed successfully!");
    }
  } else {
    Serial.printf("HTTP GET Request failed with code: %d\n", httpResponseCode);
  }
  http.end();
}
void DisplayWXicon(int x, int y, String IconName) {
  if (IconName == "01d" || IconName == "01n") {
    display.drawBitmap(x, y, sunny, 56, 48, GxEPD_BLACK);
  } else if (IconName == "02d" || IconName == "02n") {
    display.drawBitmap(x, y, mostlysunny, 56, 48, GxEPD_BLACK);
  } else if (IconName == "09d" || IconName == "09n" || IconName == "10d" || IconName == "10n") {
    display.drawBitmap(x, y, rain, 56, 48, GxEPD_BLACK);
  } else if (IconName == "11d" || IconName == "11n") {
    display.drawBitmap(x, y, tstorms, 56, 48, GxEPD_BLACK);
  } else if (IconName == "03d" || IconName == "03n" || IconName == "04d" || IconName == "04n") {
    display.drawBitmap(x, y, cloudy, 56, 48, GxEPD_BLACK);
  } else if (IconName == "13d" || IconName == "13n") {
    display.drawBitmap(x, y, snow, 56, 48, GxEPD_BLACK);
  } else if (IconName == "50d" || IconName == "50n") {
    display.drawBitmap(x, y, sleet, 56, 48, GxEPD_BLACK);
  } else {
    display.drawBitmap(x, y, nodata, 56, 48, GxEPD_BLACK);
  }
}


void DrawBattery(int x, int y) {
  uint8_t percentage = 100; // Default percentage
  float voltage = analogRead(7) / 4096.0 * 7.46; // Convert ADC value to voltage (adjust multiplier as per your voltage divider)

  if (voltage > 1) { // Check for a valid reading
    Serial.println("Voltage = " + String(voltage, 2) + "V");

    // Calculate battery percentage using the polynomial
    percentage = 2836.9625 * pow(voltage, 4) - 
                 43987.4889 * pow(voltage, 3) + 
                 255233.8134 * pow(voltage, 2) - 
                 656689.7123 * voltage + 
                 632041.7303;

    // Clamp percentage to valid range
    if (voltage >= 4.20) percentage = 100;
    if (voltage <= 3.50) percentage = 0;

    // Draw battery outline and fill it according to the percentage
    display.drawRect(x + 15, y - 12, 19, 10, GxEPD_BLACK);
    display.fillRect(x + 34, y - 10, 2, 5, GxEPD_BLACK);
    display.fillRect(x + 17, y - 10, 15 * percentage / 100.0, 6, GxEPD_BLACK);

    // Display percentage text
    String percentbattery = String(percentage) + "%";
    display.setCursor(x + 65, y - 11);
    display.print(percentbattery);

  }
}


void displayWeatherAndTime() {
    display.setPartialWindow(0, 0, display.width(), 80); // Top 80px for weather/time
    display.firstPage();
    do {
        display.fillRect(0, 0, display.width(), 80, GxEPD_WHITE); // Clear only the weather/time area

        // Weather details
        const char* weather = doc["weather"][0]["description"];
        const char* iconCode = doc["weather"][0]["icon"];
        float temp = doc["main"]["temp"];
        int hum = doc["main"]["humidity"];

        // Display weather icon
        DisplayWXicon(10, 15, String(iconCode));

        // Display weather details
        String newTime = getLocalTimeString();
        String weatherLine = String("Weather: ") + (weather ? weather : "N/A");
        String tempLine = String("Temperature: ") + String(temp, 1) + " C";
        String humidityLine = String("Humidity: ") + String(hum) + " %";

      // Display heading section
        u8g2Fonts.setFont(u8g2_font_helvB08_tf);
        display.setCursor(4, 0);
        display.print(newTime);
        DrawBattery(65, 12);
        display.drawLine(0, 12, display.width(), 12, GxEPD_BLACK);

        int16_t x = 70; // Adjust x position to leave space for the icon
        int16_t y = 20;
        int16_t lineHeight = 20;

        display.setCursor(x, y);
        display.print(weatherLine);
        y += lineHeight;

        display.setCursor(x, y);
        display.print(tempLine);
        y += lineHeight;

        display.setCursor(x, y);
        display.print(humidityLine);
    } while (display.nextPage());
}

// Function to fetch and display calendar events
void fetchAndDisplayCalendar() {
    HTTPClient http;
    http.setFollowRedirects(HTTPC_STRICT_FOLLOW_REDIRECTS);
    http.begin(CALENDAR_URL); // HTTPS connection

    int httpCode = http.GET();
    if (httpCode > 0) {
        String payload = http.getString();
        Serial.printf("Calendar fetched successfully. HTTP code: %d\n", httpCode);
        Serial.println("Payload:");
        Serial.println(payload);

        // Save to RTC memory
        if (payload.length() < sizeof(calendarPayload)) {
            payload.toCharArray(calendarPayload, sizeof(calendarPayload));
        } else {
            Serial.println("Calendar payload too large, truncating.");
            payload.substring(0, sizeof(calendarPayload) - 1).toCharArray(calendarPayload, sizeof(calendarPayload));
        }

        // Display calendar
        displayEvents(payload);
    } else {
        Serial.printf("Failed to fetch calendar. HTTP code: %d\n", httpCode);
    }
    http.end();
}

void displaySavedCalendar() {
    String payload = String(calendarPayload);
    displayEvents(payload);
}

void displayEvents(String serverPayload) {
    display.setFont(&FreeMonoBold9pt7b); // Set font for the calendar section
    display.setTextColor(GxEPD_BLACK);
    display.setPartialWindow(0, 100, display.width(), 140); // Middle section: y=100 to y=240
    display.firstPage();
    do {
        display.fillRect(0, 100, display.width(), 140, GxEPD_WHITE); // Clear the calendar area
 
        char buff[serverPayload.length() + 1];
        serverPayload.toCharArray(buff, serverPayload.length() + 1);

        char* line = strtok(buff, "\n"); // Split payload into lines
        int y = 120; // Start position for the events section

        for (int i = 0; line != NULL && i < 5; i++) { // Limit to 5 lines
            display.setCursor(10, y + (16 * i)); // Adjust spacing between lines
            display.printf("%.30s", line);      // Print up to 30 characters per line
            line = strtok(NULL, "\n");
        }
    } while (display.nextPage());
}

// Function to fetch and parse RSS feed
String fetchLatestNews() {
    HTTPClient http;
    http.begin(RSS_URL);
    int httpCode = http.GET();

    if (httpCode > 0) {
        String payload = http.getString();
        XMLDocument rssFeed;
        if (rssFeed.Parse(payload.c_str()) == XML_SUCCESS) {
            XMLElement* channel = rssFeed.FirstChildElement("rss")->FirstChildElement("channel");
            if (channel) {
                XMLElement* item = channel->FirstChildElement("item");
                newsCount = 0; // Reset title count
                while (item && newsCount < 28) {
                    XMLElement* title = item->FirstChildElement("title");
                    if (title && title->GetText()) {
                        // Directly copy the title to the RTC memory array
                        strncpy(newsTitles[newsCount], title->GetText(), sizeof(newsTitles[newsCount]) - 1);
                        newsTitles[newsCount][sizeof(newsTitles[newsCount]) - 1] = '\0'; // Ensure null-termination
                        newsCount++;
                    }
                    item = item->NextSiblingElement("item");
                }
                Serial.println("RSS Feed updated!");
                return "Success";
            }
        } else {
            Serial.println("Failed to parse RSS feed.");
            return "Parse error";
        }
    } else {
        Serial.printf("Failed to fetch RSS feed. HTTP code: %d\n", httpCode);
        return "HTTP error";
    }
    http.end();
    return "Unknown error";
}

// Function to display the news at the bottom of the screen
void displayNews(int titleIndex) {
    display.setFont(&FreeMonoBold9pt7b);
    display.setTextColor(GxEPD_BLACK);
    display.setPartialWindow(0, 240, display.width(), 60); // Bottom section: y=240 to y=300
    display.firstPage();
    do {
        display.fillRect(0, 240, display.width(), 60, GxEPD_WHITE); // Clear news area

        if (titleIndex >= 0 && titleIndex < newsCount) {
            int y = 250; // Adjust y position for news
            display.setCursor(10, y);
            
            // Split long titles into two lines if necessary
            String title = String(newsTitles[titleIndex]);
            if (title.length() > 35) {
                int splitIndex = 34;

                // Find the last space before the 40th character to split the string
                while (splitIndex > 0 && title[splitIndex] != ' ') {
                    splitIndex--;
                }

                // If no space is found, split at the 40th character anyway
                if (splitIndex == 0) {
                    splitIndex = 34;
                }

                String firstLine = title.substring(0, splitIndex);
                String secondLine = title.substring(splitIndex + 1); // +1 to skip the space
                display.print(firstLine);
                display.setCursor(10, y + 20);
                display.print(secondLine);
            } else {
                display.print(title);
            }
        } else {
            display.setCursor(10, 250);
            display.print("No news available");
        }
    } while (display.nextPage());
}

// Define each of the *icons for display
const unsigned char sunny[] PROGMEM = { // 56x48
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x7f, 0xe1, 0xff, 0x9f, 0xff, 0xff, 0xf0, 0x7f, 0xf3, 0xff, 0x0f, 0xff, 
0xff, 0xf8, 0x3f, 0xff, 0xfe, 0x07, 0xff, 0xff, 0xfc, 0x1f, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0xfe, 0x1f, 0x81, 0xfc, 0x1f, 0xff, 0xff, 0xff, 0xbc, 0x00, 0x1c, 0x7f, 0xff, 
0xff, 0xff, 0xf0, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x3e, 0x03, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0x83, 0xff, 0xff, 0xff, 0xff, 0x81, 0xff, 0xc3, 0xff, 0xff, 
0xff, 0xff, 0x81, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xff, 0x87, 0xff, 0xf0, 0xff, 0xff, 0xfc, 0x03, 0x87, 0xff, 0xf0, 0xe0, 0x3f, 0xf8, 0x01, 0x87, 0xff, 0xf0, 0xc0, 0x1f, 
0xf8, 0x01, 0x87, 0xff, 0xf0, 0xc0, 0x1f, 0xfc, 0x03, 0x87, 0xff, 0xf0, 0xe0, 0x3f, 0xff, 0xff, 0x87, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 0x81, 0xff, 0xc1, 0xff, 0xff, 
0xff, 0xff, 0xc1, 0xff, 0x83, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x7f, 0x03, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x3e, 0x03, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x06, 0xff, 0xff, 
0xff, 0xff, 0x3e, 0x00, 0x3c, 0x7f, 0xff, 0xff, 0xfc, 0x1f, 0x81, 0xfc, 0x1f, 0xff, 0xff, 0xf8, 0x3f, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0xf0, 0x7f, 0xff, 0xfe, 0x07, 0xff, 
0xff, 0xf8, 0x7f, 0xf3, 0xff, 0x0f, 0xff, 0xff, 0xfc, 0xff, 0xe1, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xf3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };

const unsigned char mostlysunny[] PROGMEM = { // 56x48
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x87, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x87, 0xff, 0xff, 
0xff, 0xff, 0xfe, 0xff, 0x87, 0xfe, 0xff, 0xff, 0xff, 0xf8, 0x7f, 0x87, 0xf8, 0x7f, 0xff, 0xff, 0xf8, 0x3f, 0xcf, 0xf0, 0x7f, 0xff, 0xff, 0xfc, 0x1f, 0xff, 0xe0, 0xff, 
0xff, 0xff, 0xfe, 0x0f, 0xff, 0xc1, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xc3, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x03, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x7f, 0xff, 
0xff, 0xff, 0xc0, 0xf8, 0x78, 0x3f, 0xff, 0xff, 0xff, 0x80, 0x00, 0xfc, 0x1f, 0xff, 0xff, 0xff, 0x00, 0x01, 0xfe, 0x0f, 0xff, 0xff, 0xfe, 0x00, 0x01, 0xff, 0x0f, 0xff, 
0xff, 0xfc, 0x00, 0x01, 0xff, 0x87, 0xff, 0xff, 0xf0, 0x7f, 0xe1, 0xff, 0xe7, 0xff, 0xff, 0xf0, 0xff, 0xf1, 0xff, 0xe7, 0xff, 0xff, 0xe1, 0xff, 0xf0, 0x7f, 0xe4, 0x07, 
0xff, 0xc3, 0xff, 0xf8, 0x1f, 0xc0, 0x03, 0xff, 0xc7, 0xff, 0xfc, 0x0f, 0x88, 0x03, 0xff, 0xc7, 0xff, 0xfe, 0x07, 0x8c, 0x07, 0xf0, 0x0f, 0xff, 0xff, 0xe3, 0x1f, 0xff, 
0xe0, 0x0f, 0xff, 0xff, 0xf0, 0x1f, 0xff, 0xe0, 0x0f, 0xff, 0xff, 0xf8, 0x3f, 0xff, 0xe0, 0x1f, 0xff, 0xff, 0xf8, 0x7f, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0xff, 
0xc7, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xfc, 0x67, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xfc, 0x67, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xfc, 0x63, 0xff, 
0x9f, 0xff, 0xff, 0xff, 0xfc, 0x61, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xfc, 0x60, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xfc, 0xf0, 0x7f, 0xcf, 0xff, 0xff, 0xff, 0xf8, 0xf8, 0x7f, 
0xcf, 0xff, 0xff, 0xff, 0xf1, 0xfc, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xf1, 0xff, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 0x83, 0xff, 0xff, 
0xe0, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };

const unsigned char rain[] PROGMEM = { // 56x48
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x0f, 0xff, 0xff, 
0xff, 0xff, 0xf0, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0x80, 0x7e, 0x01, 0xff, 0xff, 0xff, 0xff, 0x80, 0xff, 0x80, 0xff, 0xff, 
0xff, 0xff, 0x81, 0xff, 0xe0, 0x7f, 0xff, 0xff, 0xff, 0x07, 0xff, 0xf8, 0x3f, 0xff, 0xff, 0xfe, 0x1f, 0xff, 0xfc, 0x07, 0xff, 0xff, 0xfe, 0x3f, 0xff, 0xfc, 0x01, 0xff, 
0xff, 0xfc, 0x3f, 0xff, 0xfc, 0x00, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xfe, 0x00, 0x3f, 0xff, 0xc0, 0x7f, 0xff, 0xff, 0x00, 0x1f, 0xfc, 0x00, 0xff, 0xff, 0xff, 0xf8, 0x0f, 
0xf8, 0x01, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xe0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0x87, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x87, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 
0xe1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 
0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xc7, 0xff, 0xff, 0x07, 0x03, 0xff, 0x87, 
0xc3, 0xff, 0xff, 0x06, 0x07, 0xff, 0x07, 0xe1, 0xff, 0xfe, 0x0e, 0x07, 0xff, 0x07, 0xe0, 0xff, 0xfe, 0x1e, 0x0f, 0xfc, 0x0f, 0xe0, 0x3f, 0xfe, 0x1e, 0x0f, 0xf0, 0x1f, 
0xe0, 0x00, 0x3c, 0x1c, 0x1c, 0x00, 0x1f, 0xfc, 0x00, 0x78, 0x3c, 0x3c, 0x00, 0xff, 0xff, 0x00, 0x78, 0x78, 0x38, 0x03, 0xff, 0xff, 0xc0, 0x78, 0x78, 0x78, 0x0f, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xf0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xe0, 0xff, 0xff, 0xff, 
0xff, 0xff, 0x81, 0xc1, 0xff, 0xff, 0xff, 0xff, 0xff, 0x81, 0xc1, 0xff, 0xff, 0xff, 0xff, 0xff, 0x83, 0x81, 0xff, 0xff, 0xff, 0xff, 0xff, 0x83, 0x83, 0xff, 0xff, 0xff, 
0xff, 0xff, 0x07, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

const unsigned char tstorms[] PROGMEM = { // 56x48
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x03, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0x80, 0x7f, 0x80, 0xff, 0xff, 0xff, 0xff, 0x81, 0xff, 0xe0, 0x7f, 0xff, 0xff, 0xff, 0x83, 0xff, 0xf0, 0x3f, 0xff, 
0xff, 0xff, 0x07, 0xff, 0xfc, 0x1f, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xfc, 0x00, 0xff, 0xff, 0xf8, 0x3f, 0xff, 0xfe, 0x00, 0x7f, 0xff, 0xf8, 0x7f, 0xff, 0xff, 0x00, 0x3f, 
0xff, 0x00, 0x7f, 0xff, 0xff, 0xf8, 0x0f, 0xfc, 0x00, 0x7f, 0xff, 0xff, 0xfc, 0x0f, 0xf8, 0x00, 0x7f, 0xff, 0xff, 0xff, 0x07, 0xe0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xc7, 
0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xc1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 
0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 
0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xc7, 0xff, 0xf0, 0xf8, 0xf8, 0x3f, 0x87, 0xc1, 0xff, 0xf0, 0xf8, 0xf0, 0x3f, 0x07, 0xe0, 0xff, 0xc0, 0xe1, 0xe0, 0x7c, 0x0f, 
0xe0, 0x3f, 0x81, 0xe1, 0xc0, 0xf8, 0x0f, 0xf0, 0x07, 0x83, 0xc1, 0xc0, 0xf8, 0x3f, 0xfc, 0x07, 0x83, 0x83, 0x81, 0xf0, 0xff, 0xfe, 0x0f, 0x87, 0x83, 0x83, 0xf1, 0xff, 
0xff, 0xcf, 0x0f, 0x07, 0x03, 0xff, 0xff, 0xff, 0xfe, 0x1f, 0x0e, 0x00, 0x7f, 0xff, 0xff, 0xfc, 0x1f, 0x1e, 0x00, 0xff, 0xff, 0xff, 0xf8, 0x3e, 0x1e, 0x00, 0xff, 0xff, 
0xff, 0xf8, 0x7c, 0x3f, 0xe1, 0xff, 0xff, 0xff, 0xf0, 0x7c, 0x7f, 0xe1, 0xff, 0xff, 0xff, 0xf0, 0x78, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xfe, 0xf0, 0xff, 0xc3, 0xff, 0xff, 
0xff, 0xff, 0xe0, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xe1, 0xff, 0x87, 0xff, 0xff, 0xff, 0xff, 0xc1, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff, 0x83, 0xff, 0x9f, 0xff, 0xff, 
0xff, 0xff, 0x87, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

const unsigned char cloudy[] PROGMEM =  { // 56x48
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x07, 0xff, 0xff, 
0xff, 0xff, 0xf0, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0x80, 0x3e, 0x01, 0xff, 0xff, 0xff, 0xff, 0x80, 0xff, 0x80, 0xff, 0xff, 
0xff, 0xff, 0x81, 0xff, 0xe0, 0x7f, 0xff, 0xff, 0xff, 0x03, 0xff, 0xf8, 0x3f, 0xff, 0xff, 0xfe, 0x0f, 0xff, 0xfc, 0x07, 0xff, 0xff, 0xfe, 0x1f, 0xff, 0xfc, 0x01, 0xff, 
0xff, 0xfc, 0x3f, 0xff, 0xfc, 0x00, 0x7f, 0xff, 0xfc, 0x3f, 0xff, 0xfe, 0x00, 0x3f, 0xff, 0xc0, 0x7f, 0xff, 0xff, 0x00, 0x1f, 0xfc, 0x00, 0x7f, 0xff, 0xff, 0xf8, 0x0f, 
0xf8, 0x00, 0x7f, 0xff, 0xff, 0xfe, 0x0f, 0xe0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xe0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0x87, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x87, 
0xe1, 0xff, 0xff, 0xff, 0xff, 0xff, 0x87, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 
0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8f, 
0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0f, 0xe0, 0x3f, 0xff, 0xff, 0xff, 0xf0, 0x0f, 
0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x0f, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

const unsigned char snow[] PROGMEM = { // 56x48
0xff, 0xff, 0xff, 0xfc, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xfe, 0x00, 0xe0, 0x0f, 0xff, 
0xff, 0xff, 0xfc, 0x07, 0xfc, 0x07, 0xff, 0xff, 0xff, 0xe8, 0x1f, 0xfe, 0x07, 0xff, 0xff, 0xff, 0x00, 0x3f, 0xff, 0x07, 0xff, 0xff, 0xfc, 0x00, 0x7f, 0xff, 0x83, 0xff, 
0xff, 0xf0, 0x00, 0xff, 0xff, 0xc3, 0xff, 0xff, 0xc0, 0x7f, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xe0, 0x3f, 0xff, 0xc1, 0xff, 0xff, 0xff, 0xe0, 0x0f, 
0xff, 0xc3, 0xff, 0xff, 0xff, 0xe0, 0x0f, 0xfe, 0x03, 0xff, 0xff, 0xff, 0xfc, 0x07, 0xf0, 0x07, 0xff, 0xff, 0xff, 0xff, 0x03, 0xe0, 0x07, 0xff, 0xff, 0xff, 0xff, 0xe1, 
0xc0, 0x07, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x81, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 
0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 
0x83, 0xff, 0xff, 0xff, 0xff, 0xff, 0x83, 0x81, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 
0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xff, 0xff, 0xff, 0xb9, 0xef, 
0xff, 0xc7, 0xff, 0xff, 0xff, 0x09, 0x8f, 0xfc, 0x46, 0x7f, 0xff, 0xff, 0xc0, 0x1f, 0xfc, 0x04, 0x7f, 0xff, 0xff, 0xe0, 0x3f, 0xff, 0x00, 0x7f, 0xf3, 0xfc, 0x00, 0x07, 
0xff, 0x80, 0xff, 0xf1, 0xfc, 0x00, 0x07, 0xf0, 0x00, 0x1f, 0x71, 0x1f, 0xe0, 0x3f, 0xf0, 0x00, 0x1f, 0x10, 0x1f, 0xc0, 0x1f, 0xff, 0x00, 0xff, 0x80, 0xff, 0x08, 0x8f, 
0xfe, 0x00, 0x7f, 0xc0, 0xff, 0x98, 0xcf, 0xfc, 0x06, 0x7c, 0x00, 0x07, 0xf8, 0xff, 0xfc, 0xc7, 0x7c, 0x00, 0x07, 0xf9, 0xff, 0xff, 0xc7, 0xff, 0x80, 0xff, 0xff, 0xff, 
0xff, 0xef, 0xff, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x71, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xff, 0xff, 0xff};

const unsigned char sleet[] PROGMEM = { // 56x48
0xff, 0xff, 0xff, 0xfc, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xfe, 0x00, 0xe0, 0x0f, 0xff, 
0xff, 0xff, 0xfc, 0x07, 0xfc, 0x07, 0xff, 0xff, 0xff, 0xe0, 0x1f, 0xfe, 0x07, 0xff, 0xff, 0xff, 0x00, 0x3f, 0xff, 0x07, 0xff, 0xff, 0xfc, 0x00, 0x7f, 0xff, 0x83, 0xff, 
0xff, 0xf0, 0x00, 0x7f, 0xff, 0xc3, 0xff, 0xff, 0xc0, 0x7f, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xe0, 0x1f, 0xff, 0xc1, 0xff, 0xff, 0xff, 0xe0, 0x0f, 
0xff, 0x83, 0xff, 0xff, 0xff, 0xe0, 0x0f, 0xfc, 0x03, 0xff, 0xff, 0xff, 0xfc, 0x07, 0xf0, 0x07, 0xff, 0xff, 0xff, 0xff, 0x03, 0xe0, 0x07, 0xff, 0xff, 0xff, 0xff, 0xc1, 
0xc0, 0x07, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x81, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 
0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 
0x83, 0xff, 0xff, 0xff, 0xff, 0xff, 0x83, 0x81, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 
0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xe0, 0x3f, 0xff, 0x07, 0xff, 0xff, 0xff, 0xc0, 0x3f, 0xfc, 0x07, 0xff, 0xcf, 0xff, 0x80, 0x3f, 
0xf8, 0x07, 0xff, 0x8f, 0xff, 0x80, 0x3f, 0xf0, 0x07, 0xf8, 0x8c, 0xff, 0x80, 0x7f, 0xf0, 0x07, 0xf8, 0x88, 0xff, 0x80, 0x7f, 0xf0, 0x0f, 0xff, 0x01, 0xff, 0xe1, 0xff, 
0xf0, 0x0f, 0xf0, 0x00, 0x3f, 0xff, 0xff, 0xf8, 0x1f, 0xe0, 0x00, 0x3f, 0xff, 0xff, 0xff, 0x7f, 0xf0, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xfc, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x8e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcf, 0xff, 0xff, 0xff};

const unsigned char fog[] PROGMEM = { // 56x48
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xe0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x1f, 0xe0, 0xff, 0xff, 
0xff, 0xff, 0xf0, 0x7f, 0xf8, 0x7f, 0xff, 0xff, 0xff, 0xc3, 0xff, 0xfe, 0x1f, 0xff, 0xff, 0xff, 0x87, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x87, 0xff, 0xff, 0x8f, 0xff, 
0xff, 0xff, 0x8f, 0xff, 0xff, 0x87, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xc7, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xc7, 0xff, 0xfe, 0x00, 0x1f, 0xff, 0xff, 0xe7, 0xff, 
0xf8, 0x00, 0x3f, 0xff, 0xff, 0xe7, 0xff, 0xf0, 0x00, 0x3f, 0xff, 0xff, 0xe0, 0xff, 0xe0, 0xff, 0x3f, 0xff, 0xff, 0xe0, 0x1f, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0f, 
0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 
0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x80, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

const unsigned char nodata[] PROGMEM = { // 56x48
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x0f, 0xff, 0xff, 
0xff, 0xff, 0xf8, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0c, 0x07, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x3e, 0x03, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0x83, 0xff, 0xff, 
0xff, 0xff, 0xf0, 0xff, 0x83, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0x83, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x83, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x83, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x1f, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xf0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

void setup() {
    Serial.begin(115200);
    delay(100);           // Allow some time for the connection to stabilize
    Serial.println("Starting setup...");
    display.init(115200, true, 50, false); // Initialize display
    wifi_init(); // Initialize Wi-Fi
  // Check current time
    struct tm timeinfo;
    if (!getLocalTime(&timeinfo)) {
        Serial.println("Failed to obtain time. Going to sleep for default duration.");
        ESP.deepSleep(DEEP_SLEEP_DURATION * uS_TO_S_FACTOR);
        return;
    }

    int currentHour = timeinfo.tm_hour;
    Serial.printf("Current Hour: %d\n", currentHour);

    // Restrict operation based on time
    if (currentHour < WAKEUP_TIME && currentHour >= SLEEP_TIME) {
        // Calculate sleep duration until WAKEUP_TIME
        int sleepHours = WAKEUP_TIME - currentHour;
        unsigned long long extendedSleep = sleepHours * 3600 * uS_TO_S_FACTOR;
        Serial.printf("Outside operational hours. Sleeping for %d hours.\n", sleepHours);
        ESP.deepSleep(extendedSleep);
        return;
    }

    // Proceed with normal operation
    Serial.println("Within operational hours. Proceeding with tasks...");
    
    if (wakeUpCount == 0 || wakeUpCount % RSS_FETCH_INTERVAL == 0) {
        fetchLatestNews(); // Fetch RSS feed on first boot or every 1 hour
    }

    if (newsCount > 0) {
        displayNews(currentTitleIndex); // Display the current news title
        currentTitleIndex = (currentTitleIndex + 1) % newsCount; // Cycle to the next title
    } else {
        displayNews(-1); // Display "No news available"
    }

 // Handle Calendar
    if (wakeUpCount == 0 || wakeUpCount % CALENDAR_FETCH_INTERVAL == 0) {
        fetchAndDisplayCalendar(); // Fetch and display calendar every 3 hours
    } else {
        displaySavedCalendar(); // Display previously fetched calendar
    }

    // Display weather and calendar
    downloadWeather();
  
    displayWeatherAndTime();

    // Prepare for deep sleep
    wakeUpCount++;
    esp_sleep_enable_timer_wakeup(DEEP_SLEEP_DURATION * uS_TO_S_FACTOR); // Configure sleep time
    Serial.println("Going to deep sleep...");
    display.hibernate(); // Hibernate the display for battery saving
    esp_deep_sleep_start();
}

void loop() {

}

